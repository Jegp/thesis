This appendix includes data on the environment, library versions used to
execute the experiments and the generated scripts used to run the experiments.
The scripts have all been generated by the Volr compiler that is included in Appendix
\ref{app:implementation}.

\section{Hardware and library configurations}
The benchmark was run on a Linux kernel version 4.18.0, with a Intel i7-8750H
6-core CPU and a Nvidia GeForce GTX 1060 GPU.

Regarding library versions, Futhark is fixed at 0.9.0, PyNN at 0.9.3 and NEST at 2.16.0.

\section{Execution wrapper}

A wrapper was written for the experiments to ensure a homogenous execution from
the commandline as well as data injection and extraction via standard in/out.

\lstinputlisting[language=Haskell,caption={Execution wrapper for experiments}]{appendices/Main.py}

\section{Experiment code}

The following sections present the code that was used to execute the
experiments. 
Two files are provided per experiment: one for the Futhark backend and one for
NEST.

\section{NAND and XOR}

\lstinputlisting[language=]{../experiments/nand_seq.fut}
\lstinputlisting[language=]{../experiments/nand_seq_snn.py}

\section{MNIST sequential}

\lstinputlisting[language=]{../experiments/mnist.fut}
\lstinputlisting[language=]{../experiments/mnist_seq.py}

\section{MNIST parallel}

\lstinputlisting[language=]{../experiments/mnist_par.fut}
\lstinputlisting[language=]{../experiments/mnist_par_snn.py}

\section{PyNN exception in weight initialisation} \label{sec:pynn-exception}
\begin{lstlisting}[caption={PyNN exception when performing weight
initialisation during a test in \texttt{test\_merge.py}.}]
../../volrpynn/model.py:108: in predict    return self.simulate(time)                                                                                         
../../volrpynn/model.py:138: in simulate    self.reset_weights()
../../volrpynn/model.py:121: in reset_weights    layer.restore_weights()                                                                                            
../../volrpynn/layer.py:75: in restore_weights    self.set_weights(self.get_weights())
../../volrpynn/layer.py:349: in set_weights
    self.layer1.set_weights(weights[0])
../../volrpynn/layer.py:217: in set_weights
    self.projection.set(weight=normalised)
/usr/local/lib/python3.6/dist-packages/pyNN/common/projections.py:172: in set                                          
    attributes = self._value_list_to_array(attributes)
/usr/local/lib/python3.6/dist-packages/pyNN/common/projections.py:208: in _value_list_to_array                         
    connection_mask = ~numpy.isnan(self.get('weight', format='array', gather='all'))                                   
/usr/local/lib/python3.6/dist-packages/pyNN/common/projections.py:350: in get                                          
    multiple_synapses=multiple_synapses)
/usr/local/lib/python3.6/dist-packages/pyNN/nest/projections.py:362: in _get_attributes_as_arrays                      
    addr = self.pre.id_to_index(src), self.post.id_to_index(tgt)                                                       
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _          

self = Population(6, IF_cond_exp(<parameters>), structure=Line(dx=1.0, x0=0.0, y=0.0, z=0.0), label='population10')    
id = 22

    def id_to_index(self, id):
        """
            Given the ID(s) of cell(s) in the Population, return its (their) index
            (order in the Population).
    
                >>> assert p.id_to_index(p[5]) == 5
            """
        if not numpy.iterable(id):
            if not self.first_id <= id <= self.last_id:
>               raise ValueError("id should be in the range [%d,%d], actually %d" % (self.first_id, self.last_id, id))
E               ValueError: id should be in the range [11,16], actually 22

/usr/local/lib/python3.6/dist-packages/pyNN/common/populations.py:691: ValueError
\end{lstlisting}
